# -*- coding: utf-8 -*-
"""Maze_solver.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SdCcv3cX8AqrmchnllyBAaCpWGJTAhMw

# FloodFill
"""

import numpy as np
import random
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import imageio

# Directions: [East, North, West, South]
DIRECTIONS = [(1, 0), (0, 1), (-1, 0), (0, -1)]

class MazeSolver:
    def __init__(self, size):
        self.size = size
        self.position = (1, 1)
        self.exit_position = (size - 2, size - 2)
        self.map = self.generate_maze(size)
        self.images = []

    def generate_maze(self, size):
        # Prim's Algorithm for Random Maze Generation
        maze = np.ones((size, size))
        maze[1, 1] = 0
        walls = [(1, 2), (2, 1)]
        while walls:
            x, y = random.choice(walls)
            walls.remove((x, y))
            if maze[x, y] == 1:
                # Check all valid neighbors
                neighbours = [(x + dx, y + dy) for dx, dy in DIRECTIONS
                              if 0 <= x + dx < size and 0 <= y + dy < size]
                free_neighbours = [pos for pos in neighbours if maze[pos] == 0]
                if len(free_neighbours) == 1:
                    maze[x, y] = 0
                    for dx, dy in DIRECTIONS:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < size and 0 <= ny < size and maze[nx, ny] == 1:
                            walls.append((nx, ny))
        maze[self.exit_position] = 0
        return maze

    def visualize(self):
        # Full-knowledge visualization with wall segments
        fig, ax = plt.subplots(figsize=(6, 6))
        ax.set_xlim(0, self.size)
        ax.set_ylim(0, self.size)
        ax.set_xticks(np.arange(0, self.size+1, 1))
        ax.set_yticks(np.arange(0, self.size+1, 1))
        ax.grid(False)
        ax.set_aspect('equal')
        ax.set_facecolor('white')

        segments = set()
        # For each free cell in the complete maze, check if its neighbor is a wall or out-of-bound.
        for x in range(self.size):
            for y in range(self.size):
                if self.map[x, y] == 0:
                    # Left edge
                    if x - 1 < 0 or self.map[x - 1, y] == 1:
                        segments.add(((x, y), (x, y + 1)))
                    # Right edge
                    if x + 1 >= self.size or self.map[x + 1, y] == 1:
                        segments.add(((x + 1, y), (x + 1, y + 1)))
                    # Bottom edge
                    if y - 1 < 0 or self.map[x, y - 1] == 1:
                        segments.add(((x, y), (x + 1, y)))
                    # Top edge
                    if y + 1 >= self.size or self.map[x, y + 1] == 1:
                        segments.add(((x, y + 1), (x + 1, y + 1)))

        # Draw all wall segments
        for seg in segments:
            (x1, y1), (x2, y2) = seg
            ax.plot([x1, x2], [y1, y2], color='black', linewidth=2)

        # Draw current position (red) and exit (green) using circles
        ax.add_patch(patches.Circle((self.position[0] + 0.5, self.position[1] + 0.5), 0.3, color='red'))
        ax.add_patch(patches.Circle((self.exit_position[0] + 0.5, self.exit_position[1] + 0.5), 0.3, color='green'))

        plt.savefig("frame.png")
        self.images.append(imageio.imread("frame.png"))
        plt.pause(0.1)
        plt.close()

    def visualize_discovered_lines(self, discovered):
        """
        Visualize the discovered portion of the maze using line segments for walls.
        For each cell that is known to be free (discovered as 0), we check its four borders.
        If a neighbor is either out-of-bound or has been discovered as a wall (1),
        we draw that edge.
        """
        fig, ax = plt.subplots(figsize=(6, 6))
        ax.set_xlim(0, self.size)
        ax.set_ylim(0, self.size)
        ax.set_xticks(np.arange(0, self.size+1, 1))
        ax.set_yticks(np.arange(0, self.size+1, 1))
        ax.grid(False)
        ax.set_aspect('equal')
        ax.set_facecolor('white')

        segments = set()
        # Iterate only over cells that have been discovered.
        for x in range(self.size):
            for y in range(self.size):
                # Process if the cell is discovered and free.
                if discovered[x, y] == 0:
                    # Left border
                    if x - 1 < 0 or (discovered[x - 1, y] == 1):
                        segments.add(((x, y), (x, y + 1)))
                    # Right border
                    if x + 1 >= self.size or (discovered[x + 1, y] == 1):
                        segments.add(((x + 1, y), (x + 1, y + 1)))
                    # Bottom border
                    if y - 1 < 0 or (discovered[x, y - 1] == 1):
                        segments.add(((x, y), (x + 1, y)))
                    # Top border
                    if y + 1 >= self.size or (discovered[x, y + 1] == 1):
                        segments.add(((x, y + 1), (x + 1, y + 1)))

        # Draw the wall segments based on discovered information.
        for seg in segments:
            (x1, y1), (x2, y2) = seg
            ax.plot([x1, x2], [y1, y2], color='black', linewidth=2)

        # Mark the current position and exit.
        ax.add_patch(patches.Circle((self.position[0] + 0.5, self.position[1] + 0.5), 0.3, color='red'))
        ax.add_patch(patches.Circle((self.exit_position[0] + 0.5, self.exit_position[1] + 0.5), 0.3, color='green'))

        plt.title("Discovered Maze (Walls as Lines)")
        plt.savefig("frame.png")
        self.images.append(imageio.imread("frame.png"))
        plt.pause(0.1)
        plt.close()

    def run_fog_of_war_floodfill(self):
        """
        Flood fill (BFS) exploration with limited knowledge.
        The agent starts knowing only its current cell.
        When it reaches a cell, it 'senses' its immediate neighbors (revealing wall/free info).
        Walls are drawn as line segments based only on discovered cells.
        """
        plt.ion()
        # discovered: -1 = unknown, 0 = free, 1 = wall.
        discovered = np.full((self.size, self.size), -1)
        discovered[self.position[0], self.position[1]] = 0  # starting cell is free.
        visited = np.zeros((self.size, self.size), dtype=bool)
        queue = [self.position]  # Use a queue for flood fill (BFS)

        while queue:
            current = queue.pop(0)  # Dequeue the next cell
            if visited[current[0], current[1]]:
                continue
            visited[current[0], current[1]] = True
            self.position = current

            # "Sense" immediate neighbors.
            for dx, dy in DIRECTIONS:
                nx, ny = current[0] + dx, current[1] + dy
                if 0 <= nx < self.size and 0 <= ny < self.size:
                    if discovered[nx, ny] == -1:
                        discovered[nx, ny] = self.map[nx, ny]

            self.visualize_discovered_lines(discovered)
            print("Current Position:", current)

            if current == self.exit_position:
                print("Exit Found at", current)
                break

            # Add free (discovered) neighbors that have not been visited.
            for dx, dy in DIRECTIONS:
                nx, ny = current[0] + dx, current[1] + dy
                if 0 <= nx < self.size and 0 <= ny < self.size:
                    if discovered[nx, ny] == 0 and not visited[nx, ny]:
                        queue.append((nx, ny))
            plt.pause(0.1)

        plt.ioff()
        imageio.mimsave('maze_solver_floodfill_fog_lines.gif', self.images, duration=0.1)
        plt.show()

if __name__ == '__main__':
    solver = MazeSolver(15)  # Adjust the maze size as needed.
    # Run the flood-fill (BFS) fog-of-war exploration.
    solver.run_fog_of_war_floodfill()

"""# DFS"""

import numpy as np
import random
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import imageio

# Directions: [East, North, West, South]
DIRECTIONS = [(1, 0), (0, 1), (-1, 0), (0, -1)]

class MazeSolver:
    def __init__(self, size, exit_position=None):
        self.size = size
        self.position = (1, 1)
        # Use provided exit position or default to (size-2, size-2)
        if exit_position is None:
            self.exit_position = (size - 2, size - 2)
        else:
            self.exit_position = exit_position
        self.map = self.generate_maze(size)
        self.images = []

    def generate_maze(self, size):
        # Prim's Algorithm for Random Maze Generation
        maze = np.ones((size, size))
        maze[1, 1] = 0
        walls = [(1, 2), (2, 1)]
        while walls:
            x, y = random.choice(walls)
            walls.remove((x, y))
            if maze[x, y] == 1:
                # Check all valid neighbors
                neighbours = [(x + dx, y + dy) for dx, dy in DIRECTIONS
                              if 0 <= x + dx < size and 0 <= y + dy < size]
                free_neighbours = [pos for pos in neighbours if maze[pos] == 0]
                if len(free_neighbours) == 1:
                    maze[x, y] = 0
                    for dx, dy in DIRECTIONS:
                        nx, ny = x + dx, y + dy
                        if 0 <= nx < size and 0 <= ny < size and maze[nx, ny] == 1:
                            walls.append((nx, ny))
        # Ensure the exit cell is open.
        maze[self.exit_position] = 0
        return maze

    def visualize(self):
        # Full-knowledge visualization with wall segments
        fig, ax = plt.subplots(figsize=(6, 6))
        ax.set_xlim(0, self.size)
        ax.set_ylim(0, self.size)
        ax.set_xticks(np.arange(0, self.size+1, 1))
        ax.set_yticks(np.arange(0, self.size+1, 1))
        ax.grid(False)
        ax.set_aspect('equal')
        ax.set_facecolor('white')

        segments = set()
        # For each free cell in the complete maze, check if its neighbor is a wall or out-of-bound.
        for x in range(self.size):
            for y in range(self.size):
                if self.map[x, y] == 0:
                    # Left edge
                    if x - 1 < 0 or self.map[x - 1, y] == 1:
                        segments.add(((x, y), (x, y + 1)))
                    # Right edge
                    if x + 1 >= self.size or self.map[x + 1, y] == 1:
                        segments.add(((x + 1, y), (x + 1, y + 1)))
                    # Bottom edge
                    if y - 1 < 0 or self.map[x, y - 1] == 1:
                        segments.add(((x, y), (x + 1, y)))
                    # Top edge
                    if y + 1 >= self.size or self.map[x, y + 1] == 1:
                        segments.add(((x, y + 1), (x + 1, y + 1)))

        # Draw all wall segments
        for seg in segments:
            (x1, y1), (x2, y2) = seg
            ax.plot([x1, x2], [y1, y2], color='black', linewidth=2)

        # Draw current position (red) and exit (green) using circles
        ax.add_patch(patches.Circle((self.position[0] + 0.5, self.position[1] + 0.5), 0.3, color='red'))
        ax.add_patch(patches.Circle((self.exit_position[0] + 0.5, self.exit_position[1] + 0.5), 0.3, color='green'))

        plt.savefig("frame.png")
        self.images.append(imageio.imread("frame.png"))
        plt.pause(0.1)
        plt.close()

    def visualize_discovered_lines(self, discovered):
        """
        Visualize the discovered portion of the maze using line segments for walls.
        For each cell that is known to be free (discovered as 0), we check its four borders.
        If a neighbor is either out-of-bound or has been discovered as a wall (1),
        we draw that edge.
        """
        fig, ax = plt.subplots(figsize=(6, 6))
        ax.set_xlim(0, self.size)
        ax.set_ylim(0, self.size)
        ax.set_xticks(np.arange(0, self.size+1, 1))
        ax.set_yticks(np.arange(0, self.size+1, 1))
        ax.grid(False)
        ax.set_aspect('equal')
        ax.set_facecolor('white')

        segments = set()
        # Iterate only over cells that have been discovered.
        for x in range(self.size):
            for y in range(self.size):
                # Only process if the cell is discovered and free.
                if discovered[x, y] == 0:
                    # Left border
                    if x - 1 < 0 or (discovered[x - 1, y] == 1):
                        segments.add(((x, y), (x, y + 1)))
                    # Right border
                    if x + 1 >= self.size or (discovered[x + 1, y] == 1):
                        segments.add(((x + 1, y), (x + 1, y + 1)))
                    # Bottom border
                    if y - 1 < 0 or (discovered[x, y - 1] == 1):
                        segments.add(((x, y), (x + 1, y)))
                    # Top border
                    if y + 1 >= self.size or (discovered[x, y + 1] == 1):
                        segments.add(((x, y + 1), (x + 1, y + 1)))

        # Draw the wall segments based on discovered information.
        for seg in segments:
            (x1, y1), (x2, y2) = seg
            ax.plot([x1, x2], [y1, y2], color='black', linewidth=2)

        # Mark the current position and exit.
        ax.add_patch(patches.Circle((self.position[0] + 0.5, self.position[1] + 0.5), 0.3, color='red'))
        ax.add_patch(patches.Circle((self.exit_position[0] + 0.5, self.exit_position[1] + 0.5), 0.3, color='green'))

        plt.title("Discovered Maze (Walls as Lines)")
        plt.savefig("frame.png")
        self.images.append(imageio.imread("frame.png"))
        plt.pause(0.1)
        plt.close()

    def run_fog_of_war(self):
        """
        DFS exploration with limited knowledge.
        The agent starts knowing only its current cell.
        When it reaches a cell, it 'senses' its immediate neighbors (revealing wall/free info).
        Walls are drawn as line segments (only for discovered cells).
        """
        plt.ion()
        # Re-generate the maze so each run is random.
        self.map = self.generate_maze(self.size)
        self.position = (1, 1)
        # Ensure the exit cell is open (if using a custom exit position).
        self.map[self.exit_position] = 0
        self.images = []

        # discovered: -1 = unknown, 0 = free, 1 = wall.
        discovered = np.full((self.size, self.size), -1)
        discovered[self.position[0], self.position[1]] = 0  # starting cell is free.
        visited = np.zeros((self.size, self.size), dtype=bool)
        stack = [self.position]

        while stack:
            current = stack.pop()
            if visited[current[0], current[1]]:
                continue
            visited[current[0], current[1]] = True
            self.position = current

            # "Sense" immediate neighbors.
            for dx, dy in DIRECTIONS:
                nx, ny = current[0] + dx, current[1] + dy
                if 0 <= nx < self.size and 0 <= ny < self.size:
                    if discovered[nx, ny] == -1:
                        discovered[nx, ny] = self.map[nx, ny]

            self.visualize_discovered_lines(discovered)
            print("Current Position:", current)

            if current == self.exit_position:
                print("Exit Found at", current)
                break

            # Add free (discovered) neighbors that have not been visited.
            for dx, dy in DIRECTIONS:
                nx, ny = current[0] + dx, current[1] + dy
                if 0 <= nx < self.size and 0 <= ny < self.size:
                    if discovered[nx, ny] == 0 and not visited[nx, ny]:
                        stack.append((nx, ny))
            plt.pause(0.1)

        plt.ioff()
        imageio.mimsave('maze_solver_dfs_fog_lines.gif', self.images, duration=0.1)
        plt.show()

if __name__ == '__main__':
    # Example: Set target exit coordinate to (5, 5) in a 15x15 maze.
    solver = MazeSolver(50, exit_position=(4, 4))
    solver.run_fog_of_war()